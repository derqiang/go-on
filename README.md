
### TIPS

1. *在包级别声明的变量会在main入口函数执行前完成初始化*
2. string -> []rune 的过程，是UTF8编码的字符串解码为Unicode字符序列的过程； 而反之，则是Unicode字符slice或者数组进行UTF8编码的过程；
3. 所以，基于上一条，rune是一个uint32类型，表示一个Unicode编码的码点
4. Golang中的字符串，如果进行拼接的话，会执行很多次分配和复制的过程（由于字符串不可变），此时，要考虑使用bytes.Buffer类型 （P_107）
5. 格式化打印占位符含义:
    ```
   // 通过%T参 数打印类型信息:
   %T 类型信息
   %v 值
   %#v 包含的#副词， 它表示用和Go语言类似的语法打印值，例如打印结构体对象时，打印出的是实例对象完整的嵌套结构信息 
   %q  原始字符串，包含引号
   %x
   %b
   %t bool值
   %s 字符串
   %9.9s 预留出9个字符的位置，并且填充最多9个字符，并且右对齐，如： ch4/json/github/SearchIssues, 如果是 %.9 就是取出9个字符进行左对齐了
   %d 数值
   %-5d 预留5个位置进行显示，并且负号表示在预留的位置内进行左对齐显示，如果不加负号就是右对齐显示
   %g	%e for large exponents, %f otherwise. Precision is discussed below.
   %G	%E for large exponents, %F otherwise
    ```
6. 批量常量声明方式，除了第一个常量外，其他均可以省略初始化表达式；如果省略，则表示使用前面的常量值进行初始化；
7. 常量可以没有基础类型，即它可以是任意类型，不需要进行强转，直接参与运算，在运算过程中进行隐式转换 （P_116）
8. 数组有一个固定长度的特定类型的元素组成的序列；数组的长度，在编译阶段即确定了
9. Slice 底层是数组，本身很轻量，只是有指针、长度和容量组成
10. Slice 切片操作在长度超出容量的时候会导致异常，但是超出长度，则一位置扩展了Slice，新slice的长度会变大
11. slice 为nil，即其len和cap都为0
12. slice可以通过make函数，创建一个匿名的数组变量，并返回一个slice；可以选择指定cap参数，来提前为未来增长的元素留下空间
13. 每次在向slice追加元素时，如果容量不够，会触发底层数组拷贝
14. map 的key最好不要是float类型，因为NaN和任何float都不相等（最坏情况）且key需要能够保证==的比较操作结果
15. delete 删除map的元素
16. map的所有操作都是安全的，例如访问不存在的key，会得到对应的类型的零值
17. map的元素值并不是变量，不能使用取地址符得到其对应的指针
18. Go中struct结构体成员定义的顺序，会定义不同的类型，使得虽然成员相同但是结构体类型不同
19. 一个命名为S的结构体类型将不能再包含S类型的成员:因为一个聚合的值不能包含它自身。 (该限制同样适应于数组。) (P_144)
20. 结构体中的匿名成员，可以不通过点语法的形式连续获取到目标成员，可以直接获取，但是字面值赋值的过程需要完整的嵌套结构表示出来才可以(P_149)
21. 结构体的匿名成员，事实上可以包含任何类型，不一定是结构体类型，因为还可以暴露任意类型上的方法集
22. 结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:"value"键值 对序列;因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。
json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/...下面其它的 包也遵循这个约定
23. Tag还带了一个额外 的`omitempty`选项，表示当Go语言结构体成员为空或零值时不生成JSON对象(这里false为零值)
24. Go编译器对函数内联化的优化，有时候影响我们对堆栈崩溃的分析，所以可以通过如`go run -gcflags="l" xx.go`的方式，禁止函数内联优化
25. Go中defer和return执行的先后顺序问题？return本身不是原子操作，而是把返回值放到栈上，然后执行defer，最后返回值给调用者
26. html/template包会自动将特殊字符转义，这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输
出，从而让他们控制页面
27. 函数的参数变量，使用下划线符号修饰其类型，表示某个参数未被使用; Go中的函数没有默认参数，后者命名参数，形参和返回值的变量名对于函数调用者没有意义。
28. Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归 时不必考虑溢出和安全问题。
29. `fmt.Errorf` 输出Error报错信息; `log.Printf()` golang自定的日志打印
30. 虽然Go的垃圾回收机制会回 收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此 我们必须显式的释放这些资源。（P173）
31. 如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。(通过返回值的命名识别要返回的变量)这称之为bare return。（P174）
32. Go中对程序处理异常（预期内的），以返回值的形式进行处理主要因为`Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的 形式抛出会混乱对错误的描述，
这通常会导致一些糟糕的后果。当某个程序错误被当作异常 处理后，这个错误会将堆栈根据信息返回给终端用户，这些信息复杂且无用，无法帮助定位 错误。`（P177）
33. 接收器是否为指针类型，不会影响编码中的调用形式：在为Golang中的结构体绑定方法和执行方法时，无论是否通过什么接收器（指针或者值类型）调用其方法，都会由编译器自动解引用或者获取
引用，进而能够调用互相作为接收器的方法（P214）
34. **Nil 也是一个合法的接收器类型 （P215）**
35. 内嵌结构体扩展类型，将内嵌结构体拥有的方法和属性直接撒出来，给外部结构体调用
36. 方法值和方法表达式:在一个包的API需要一个函数值,且调用方希望操作的是某一个绑定了对象的方法的话，方法"值"会非常实用（P222）
37. Bit数组或者Bit集合，主要目标是为了最大化"数据密度（数据/?bit）",即：最好让1个bit，就能记住一个完整的十进制数(也可以是其他数据) (P225)
38. 防止接口有非空，但是其中还有的对象值为空，从而导致接收者方法调用崩溃的情况（ch7.5.1 - P247 - ch7/interface_value）
39. 从像`ch7->sort.go->byArtist`这种排序接口的实现过程中，感觉到Golang对新功能的扩展能力的支持，很轻量，例如这个例子里，仅仅共享底层slice,但是让
新的类型去实现不同的接口以及封装对应的功能（按照不同的目的进行排序），最后在需要调用某些功能时，进行转化（强转）即可
40. 当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前
41. channel的使用可以串联
42. channel在发送者想要不再需要channel时候，可以通过内置close方法进行关闭；关闭后，再发送数据就是panic了；接收方不再阻塞，并立即得到一个零值，但是没有办法测试一个channel是否关闭，
所以，可以从接收的一个布尔值中得到一个状态
43. goroutines泄漏的情形： 在一个缓存channel中，只是取出了一部分值，例如`P310 - ch8 - buffer_chan`, 因此确保每个不再需要的goroutine能正常退出是重要的；
所以，特别注意channel的生命周期啊!
44. 千万注意： **任何情况下（代码正常执行完成和每一个可能得异常执行被迫完成），确保goroutine和channel的正确释放**
45. Golang中函数的 所有者部分，参数部分，带命名的返回值部分，均可以作为当前函数的变量直接使用（ch8-thumbnail.go-make5）; 


## Sense
1. Go语言的了解过程中，越发觉得这个语言在试图用各种抽象数据结构隔离具体的实际存储性数据结构，让内存的控制变的自动化和封装性更高，避免操作者过多干预
内存的使用过程，比如Map不允许用地址取值，是为了方便内存自动随着元素数量的增长而使用更大的存储空间
2. 为什么要用开头字母的大小写来表示导出与否？
3. 分解问题和时空调度的能力，决定核心能力
4. 组合是Go语言中面向对象编程的核心


## Framework & Lib
1. 依赖注入的理念，翻译俗话叫做"衣来张手，饭来张口，想要就有"